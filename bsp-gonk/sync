#!/bin/bash

cd $(dirname $0)

board=$(readlink .repo/board)
product=$(readlink .repo/product)
default_board=$(readlink board/.default)
default_product=$(readlink product/.default)

usage () {
  local exitcode=0
  if [[ -n ${1:-} ]]; then
    exitcode=1
    echo Error: $@
    echo
  fi
  echo "usage: $0 [board] [product]"
  echo
  echo Prepares the workspace for building the specified board and product
  echo
  if [[ -d board ]]; then
    cd board
    echo Default board: $default_board
    echo Available boards:
    for board in *; do
      if [[ -r $board/gonk.sh ]]; then
        board_product=
        if [[ -r $board/default_product ]]; then
          board_product=$(cat $board/default_product)
        else
          board_product=$default_product
        fi
        printf " * %-24s %s\n" $board "(default product: $board_product)"
      fi
    done
    cd ..
  else
    echo "No boards available"
  fi

  echo
  if [[ -d product ]]; then
    cd product
    echo Available products:
    for product in *; do
      if [[ -r $product/$product.xml ]]; then
        echo "  * $product"
      fi
    done
    cd ..
  else
    echo "No products available"
  fi
  exit $exitcode
}

repo=${REPO:-./repo}
repo_init_host=$(uname | tr A-Z a-z)
repo_init_version="--repo-url=git://codeaurora.org/tools/repo.git --repo-branch=caf-stable"
repo_init_depth="--depth=1"
repo_sync_j=-j4

sync_l=true
sync_n=true

while getopts "h?nlif" opt; do
  case $opt in
  h|\?)
    usage
    ;;
  f)
    repo_init_depth=""
    ;;
  n)
    sync_n=true
    sync_l=false
    ;;
  l)
    sync_n=false
    sync_l=true
    ;;
  i)
    sync_n=false
    sync_l=false
    ;;
  *)
    usage Unknown option: $opt
    ;;
  esac
done

shift $(($OPTIND - 1))

[[ $# -le 2 ]] || usage

arg_board=
arg_product=
if [[ $# -eq 1 ]]; then
  if [[ -d product/$1 ]]; then
    arg_product=$1
    if [[ -d board/$1 ]]; then
      echo Cannot have a board and product with the same name: $1
      exit 1
    fi
  else
    arg_board=$1
  fi
elif [[ $# -eq 2 ]]; then
  arg_board=$1
  arg_product=$2
fi

board=${arg_board:-$board}
board=${board:-$default_board}

product=${arg_product:-$product}
if [[ -r board/$board/default_product ]]; then
  board_product=$(cat board/$board/default_product)
  product=${product:-$board_product}
fi
product=${product:-$default_product}

[[ -n $board ]] || usage board is not defined
[[ -n $product ]] || usage product is not defined
[[ -d board/$board ]] || usage board directory missing: board/$board/
[[ -d product/$product ]] || usage product directory missing: product/$product/
[[ -r board/$board/$board.xml ]] || usage board manifest missing: board/$board/$board.xml
[[ -r product/$product/$product.xml ]] || usage product manifest missing: product/$product/$product.xml

set -e

mkdir -p .repo
ln -fs $board .repo/board
ln -fs $product .repo/product

function presync() {
  for what in board/$board product/$product; do
    if [[ -x $what/presync ]]; then
      ( set -x; $what/presync )
    fi
  done
}
presync

if [[ ! -d .repo/.git ]]; then
  # Construct an empty .git in .repo/ to prevent |git clean -dfx| from removing
  # the hard-earned contents of .repo/{projects,project-objects}
  mkdir -p .repo
  cd .repo
  git init --quiet .
  git commit --allow-empty -m 'Empty'
  cd ..
fi

# Recreate the ephemeral manifest projects
rm -rf .repo/manifest_upstream
rm -rf .repo/manifests
rm -rf .repo/manifests.git

# Construct a faux 'upstream' manifest project to keep repo content.  Its
# manifest .xml files redirect out to {board,product}/*/*.xml so that local
# edits to manifest files will be picked up immediately by a |repo sync|
allmanifests=({board,product}/*/*.xml)
mkdir -p .repo/manifest_upstream
cd .repo/manifest_upstream
git init --quiet .
for f in ${allmanifests[@]}; do
  ln -sf ../../$f .
done

echo '<?xml version="1.0"?>' > default.xml
cat >> default.xml <<MANIFEST
<manifest>
  <!-- Autogenerated by $0 -->
  <include name="$board.xml"/>
  <include name="$product.xml"/>
</manifest>
MANIFEST

git add *
git commit -q -m '301 Moved Permanently'
cd ../..
pwd
# Re-init the real manifest
(
set -x
$repo init \
  $repo_init_depth \
  --quiet \
  -u $PWD/.repo/manifest_upstream \
  $repo_init_version \
  -g all,-notdefault,-x86,-mips,-linux,-darwin,-flo,-flounder,-fugu,-grouper,-manta,$repo_init_host \

)

function postsync() {
  synctype=$1
  for what in board/$board product/$product; do
    if [[ -x $what/postsync ]]; then
      ( set -x; $what/postsync $synctype )
    fi
  done
}

if $sync_n; then
  ./repocache fetch $board $product
  $repo sync -n $repo_sync_j --quiet --current-branch --no-tags
  postsync -n
fi
if $sync_l; then
  $repo sync -l --quiet
  postsync -l
  touch .repo/lastsync

  # Force re-patching on next build/envsetup.sh
  ( set -x; rm -f out/lastpatch.md5sum )
fi
